# -*- coding: utf-8 -*-
"""image_processing.ipynb

Generated by Colaboratory and edited.

This module is a 'tidied' version of code for generating images in 
https://drive.google.com/drive/folders/1EuBquiI1NcB3KgwOgFFOGsnnF9s7-1L7?usp=sharing



"""

# Importing libraries
import urllib.request
import dlib
import cv2
try:
  from google.colab.patches import cv2_imshow
except:
  print("Current runtime not on Google Colab.")
  print("Images will not be able to show within notebook.")
    
# Download the image 
def downloadImage(url,output_file='test.jpg'):
  request = urllib.request.urlretrieve(url,output_file) 

"""
faceAlignmentFromImage: cv2 image (type numpy.ndarray), dict -> cv2 image (type numpy.ndarray))
Read image and dictionary of model, return face aligned image

faceAlignmentFromFile: image location, dict -> cv2 image (type numpy.ndarray))
Read location string of image and dictionary of model, return face aligned image
"""
def faceAlignmentFromImage(img, f='Image',models={}):
  if 'detector' not in models:
    models['detector'] = dlib.get_frontal_face_detector()
  if 'predictor' not in models:
    try:
      models['predictor'] = dlib.shape_predictor('shape_predictor_68_face_landmarks.dat')
    except:
      print('Predictor not found.')
  print("Processing file: {}".format(f))

  detector = models['detector']
  predictor = models['predictor']

  dets = detector(img, 1)
  print("Number of faces detected: {}".format(len(dets)))
  for k, d in enumerate(dets):
      # print("Detection {}: Left: {} Top: {} Right: {} Bottom: {}".format(
      #     k, d.left(), d.top(), d.right(), d.bottom()))
      # Get the landmarks/parts for the face in box d.
      shape = predictor(img, d)
      # print("Part 0: {}, Part 1: {} ...".format(shape.part(0),
      #                                           shape.part(1)))
      shape = face_utils.shape_to_np(shape) #gfg
      
      # We then convert dlib's rectangle to a OpenCV-style bounding box 
      # [i.e., (x, y, w, h)], then can draw the face bounding box 
      (x, y, w, h) = face_utils.rect_to_bb(d) 
      cv2.rectangle(img, (x, y), (x + w, y + h), (255, 255, 0), 1) 

      # We then loop over the (x, y)-coordinates for the facial landmarks  
      # and draw them on the image 
      for (x, y) in shape: 
          cv2.circle(img, (x, y), 2, (0, 0, 255), -1) 
      # Draw the face landmarks on the screen.
      # win.add_overlay(shape)
  try:
    cv2_imshow(img)
  except:
    print("Image cannot be preview.")
  return img


def faceAlignmentFromFile(f='test.jpg',models={}):
  img = cv2.imread(f)
  return faceAlignmentFromImage(img,f,models)

